"""
Generated MCP Tool Implementations

This module contains MCP tool implementations that wrap API client operations.
Each tool corresponds to an API operation and handles parameter validation,
API calls, and response formatting.

Generated by mcp-cli tool mapper.
"""

import logging
from typing import Dict, Any, List, Optional, Union
from mcp.server import Server
from mcp.types import Tool, TextContent

# Import generated API client classes
{% for api_class in api_classes %}
from {{ client_package_name }}.api.{{ api_class.module }} import {{ api_class.name }}
{% endfor %}

# Import models if available
{% for model in models %}
from {{ client_package_name }}.models.{{ model.name|lower }} import {{ model.name }}
{% endfor %}

logger = logging.getLogger(__name__)

class GeneratedMCPTools:
    """
    MCP tools implementation using generated API client
    
    Provides MCP-compliant tools for accessing API functionality.
    Each tool wraps a specific API operation with proper error handling
    and response formatting.
    """
    
    def __init__(self, server: Server, api_client):
        """
        Initialize tools with server and API client
        
        Args:
            server: MCP server instance
            api_client: Generated API client instance
        """
        self.server = server
        self.api_client = api_client
        
        # Initialize API class instances
        {% for api_class in api_classes %}
        self.{{ api_class.name|lower }} = {{ api_class.name }}(api_client)
        {% endfor %}
        
        self._register_tools()
    
    def _register_tools(self):
        """Register all tools with the MCP server"""
        # Tools are registered via decorators below
        pass
    
    async def list_available_tools(self) -> List[Tool]:
        """
        Get list of all available tools
        
        Returns:
            List[Tool]: Available MCP tools
        """
        tools = [
            {% for tool in tool_definitions %}
            Tool(
                name="{{ tool.name }}",
                description="{{ tool.description }}",
                inputSchema={{ tool.input_schema|tojson }}
            ),
            {% endfor %}
        ]
        return tools
    
    async def execute_tool(self, name: str, arguments: Dict[str, Any]) -> Any:
        """
        Execute a tool by name
        
        Args:
            name: Tool name to execute
            arguments: Tool arguments
            
        Returns:
            Any: Tool execution result
        """
        {% for tool in tool_definitions %}
        if name == "{{ tool.name }}":
            return await self._{{ tool.name }}(arguments)
        {% endfor %}
        
        raise ValueError(f"Unknown tool: {name}")
    
    # Tool implementations
    {% for tool in tool_definitions %}
    
    async def _{{ tool.name }}(self, arguments: Dict[str, Any]) -> Union[str, Dict[str, Any]]:
        """
        {{ tool.description }}
        
        Args:
            arguments: Tool arguments
            {% for param_name, param_def in tool.input_schema.get('properties', {}).items() %}
            - {{ param_name }} ({{ param_def.get('type', 'any') }}): {{ param_def.get('description', 'No description') }}
            {% endfor %}
            
        Returns:
            Union[str, Dict[str, Any]]: Tool execution result
        """
        try:
            logger.info(f"Executing tool {{ tool.name }} with arguments: {arguments}")
            
            # Extract and validate parameters
            {% for param_name in tool.input_schema.get('required', []) %}
            if "{{ param_name }}" not in arguments:
                raise ValueError("Required parameter '{{ param_name }}' is missing")
            {% endfor %}
            
            # Prepare API call parameters
            {% if tool.operation.parameters %}
            api_params = {}
            {% for param in tool.operation.parameters %}
            {% if param.get('in') == 'path' %}
            # Path parameter: {{ param.get('name') }}
            if "{{ param.get('name') }}" in arguments:
                api_params["{{ param.get('name') }}"] = arguments["{{ param.get('name') }}"]
            {% elif param.get('in') == 'query' %}
            # Query parameter: {{ param.get('name') }}
            if "{{ param.get('name') }}" in arguments:
                api_params["{{ param.get('name') }}"] = arguments["{{ param.get('name') }}"]
            {% endif %}
            {% endfor %}
            {% else %}
            api_params = {}
            {% endif %}
            
            # Handle request body if present
            {% if tool.operation.request_body_type %}
            if "body" in arguments:
                api_params["body"] = arguments["body"]
            {% endif %}
            
            # Make API call
            api_instance = self.{{ tool.operation.api_class|lower }}
            {% if tool.operation.method.upper() == 'GET' %}
            result = api_instance.{{ tool.operation.name }}(**api_params)
            {% elif tool.operation.method.upper() == 'POST' %}
            result = api_instance.{{ tool.operation.name }}(**api_params)
            {% elif tool.operation.method.upper() == 'PUT' %}
            result = api_instance.{{ tool.operation.name }}(**api_params)
            {% elif tool.operation.method.upper() == 'DELETE' %}
            result = api_instance.{{ tool.operation.name }}(**api_params)
            {% elif tool.operation.method.upper() == 'PATCH' %}
            result = api_instance.{{ tool.operation.name }}(**api_params)
            {% else %}
            result = api_instance.{{ tool.operation.name }}(**api_params)
            {% endif %}
            
            # Format response
            if result is None:
                return "Operation completed successfully"
            elif hasattr(result, 'to_dict'):
                return result.to_dict()
            elif isinstance(result, (dict, list, str, int, float, bool)):
                return result
            else:
                return str(result)
                
        except Exception as e:
            logger.error(f"Error executing tool {{ tool.name }}: {e}")
            error_msg = f"Error executing {{ tool.name }}: {str(e)}"
            return {"error": error_msg, "tool": "{{ tool.name }}"}
    {% endfor %}
    
    def _format_error_response(self, tool_name: str, error: Exception) -> Dict[str, Any]:
        """
        Format error response for consistent error handling
        
        Args:
            tool_name: Name of the tool that failed
            error: Exception that occurred
            
        Returns:
            Dict[str, Any]: Formatted error response
        """
        return {
            "error": str(error),
            "tool": tool_name,
            "type": type(error).__name__
        }
    
    def _validate_parameters(self, tool_name: str, arguments: Dict[str, Any], 
                           required_params: List[str]) -> None:
        """
        Validate that all required parameters are present
        
        Args:
            tool_name: Name of the tool being validated
            arguments: Provided arguments
            required_params: List of required parameter names
            
        Raises:
            ValueError: If required parameters are missing
        """
        missing_params = [param for param in required_params if param not in arguments]
        if missing_params:
            raise ValueError(f"Tool {tool_name} missing required parameters: {', '.join(missing_params)}") 