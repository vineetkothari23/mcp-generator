"""
{{ project_name }} - Server Tests

Unit tests for the MCP server implementation.
Tests server initialization, tool registration, and request handling.

Generated by mcp-cli tool.
"""

import pytest
from unittest.mock import AsyncMock, patch
from mcp_{{ service_name }}.server import {{ service_name|pascal_case }}Server
from mcp_{{ service_name }}.config import {{ service_name|pascal_case }}Config

class Test{{ service_name|pascal_case }}Server:
    """Test cases for {{ service_name|pascal_case }}Server"""
    
    def test_server_initialization(self, test_config):
        """Test server initializes correctly"""
        server = {{ service_name|pascal_case }}Server(test_config)
        
        assert server.config == test_config
        assert server.server.name == "{{ project_name }}"
        assert server.client is not None
        assert server.tools is not None
    
    @pytest.mark.asyncio
    async def test_server_start_stop(self, test_config):
        """Test server start and stop lifecycle"""
        server = {{ service_name|pascal_case }}Server(test_config)
        
        # Mock the server.run() method to avoid actual startup
        with patch.object(server.server, 'run', new_callable=AsyncMock) as mock_run:
            # Test start
            await server.start()
            mock_run.assert_called_once()
        
        # Test stop
        with patch.object(server.client, 'close', new_callable=AsyncMock) as mock_close:
            await server.stop()
            mock_close.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_tool_execution_success(self, test_config, mock_client):
        """Test successful tool execution"""
        server = {{ service_name|pascal_case }}Server(test_config)
        server.client = mock_client
        
        # Mock tools.execute_tool
        with patch.object(server.tools, 'execute_tool', new_callable=AsyncMock) as mock_execute:
            mock_execute.return_value = "Hello, World!"
            
            # This would be called by the MCP protocol handler
            result = await server.tools.execute_tool("hello_world", {"name": "World"})
            
            assert result == "Hello, World!"
            mock_execute.assert_called_once_with("hello_world", {"name": "World"})
    
    @pytest.mark.asyncio
    async def test_tool_execution_error(self, test_config, mock_client):
        """Test tool execution error handling"""
        server = {{ service_name|pascal_case }}Server(test_config)
        server.client = mock_client
        
        # Mock tools.execute_tool to raise an exception
        with patch.object(server.tools, 'execute_tool', new_callable=AsyncMock) as mock_execute:
            mock_execute.side_effect = ValueError("Invalid tool")
            
            with pytest.raises(ValueError, match="Invalid tool"):
                await server.tools.execute_tool("invalid_tool", {}) 